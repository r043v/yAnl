int tetriswasinit=0 ;uint Gtris_Pal[256] = { /*  need to really fix for flu- !!  */      0xE7BF, 0xF7FF, 0xF7FF, 0xFFFF, 0xFFFF, 0x45, 0x5FD, 0xFFFF, 0xFF3D, 0x3D7F, 0xD07F, 0x9601, 0xAEC1, 0xC741, 0xDF81, 0,       0x541, 0x8D41, 0xAD41, 0x6601, 0x8EC1, 0x9F41, 0xB781, 0xC7C1, 0x601, 0x8601, 0xAE01, 0xC601, 0x76C1, 0x8741, 0x9F81, 0xB7C1,       0x6C1, 0x86C1, 0xAEC1, 0xC6C1, 0xDE81, 0xEE41, 0x7F81, 0x97C1, 0xAF41, 0x741, 0xFFFF, 0xC741, 0xDF41, 0xEF01, 0xF701, 0x87C1,       0x781, 0x8781, 0xAF81, 0xC781, 0xDF81, 0xEF81, 0xF781, 0xFF41, 0xFC1, 0x87C1, 0xAFC1, 0xC7C1, 0xDFC1, 0xEFC1, 0xF7C1, 0xFFC1,       0x2B, 0x802B, 0xA82B, 0xC02B, 0xD82B, 0xE82B, 0xF02B, 0xF82B, 0x3AB, 0x217F, 0xF93F, 0xF9ED, 0xFAA9, 0xFB29, 0xFB69, 0x7FFF,       0x4EB, 0x277F, 0x4E7F, 0x66BF, 0x76BF, 0x86FF, 0x96FF, 0xA73F, 0x62F, 0x3FEB, 0x67D9, 0xFFD9, 0xEFDD, 0xFFE1, 0xFFA5, 0xA67F,       0x6EF, 0x57E7, 0x7FDD, 0xC7DD, 0xFFDD, 0xDFE1, 0xEFE5, 0xF7E9, 0x76F, 0x67E7, 0x8FE1, 0xBFE1, 0xE7E1, 0xFFE1, 0xD7E5, 0xE7E9,       0x7A9, 0x6FE7, 0x97E5, 0xBFE5, 0xD7E5, 0xEFE5, 0xFFE5, 0xD7E9, 0x7E7, 0x7FE7, 0xA7E9, 0xBFE9, 0xD7E9, 0xE7E9, 0xF7E9, 0xFFE9,       0x37, 0x7837, 0xA037, 0xB837, 0xD037, 0xE837, 0xF037, 0xF837, 0x477, 0x52BF, 0x9ABF, 0xD2BF, 0xFABF, 0xFB39, 0xFB77, 0xFBF5,       0x4B7, 0x557F, 0x73FF, 0xBBBF, 0xFBBF, 0xFC39, 0xFCB5, 0xFD35, 0x577, 0x563F, 0x767F, 0x8CBF, 0xFC7F, 0xFCF5, 0xFD73, 0xFDF5,       0x637, 0x577F, 0x77BF, 0x8FBF, 0xFF3D, 0xB77F, 0xBF7F, 0xCFBF, 0x73B, 0x67FD, 0x87FB, 0x9FF5, 0xB7ED, 0xFFED, 0xF7EF, 0xFFF3,       0x7BB, 0x6FF9, 0x97F5, 0xAFF3, 0xC7EF, 0xE7EF, 0xFFEF, 0xEFF3, 0x7FB, 0x7FF5, 0xA7F3, 0xBFF3, 0xCFF3, 0xE7F3, 0xF7F3, 0xFFF3,       0x3D, 0x783D, 0xA03D, 0xB83D, 0xD03D, 0xE03D, 0xF03D, 0xF83D, 0x4BD, 0x6BBF, 0x9B7F, 0xBB7F, 0xD37F, 0xEB7F, 0xFB7F, 0xFBFD,       0x5FD, 0x6D7F, 0x94BF, 0xB4BF, 0xD4BF, 0xE4BF, 0xFCBF, 0xFD3D, 0x57D, 0x6E3F, 0x95FF, 0xAD7F, 0xCD7F, 0xE57F, 0xFD7F, 0xFDFD,       0x5FD, 0x6E7F, 0x96FF, 0xAEBF, 0xBE3F, 0xE5FF, 0xFDFF, 0xFE7D, 0x6BD, 0x6EFF, 0x96FF, 0xAF3F, 0xBF3F, 0xCEBF, 0x423F, 0xFEFB,       0x6FD, 0x6FBF, 0x97BF, 0xAFBF, 0xBFFF, 0xCFFF, 0xFFFF, 0xC63F, 0xA73F, 0x15FF, 0x17C5, 0xFFC5, 0x10BF, 0xF8BF, 0x173F, 0xFFFF};int downSpeed = 1242 ;#include	"./tetris.h"char * sugarMelody = 0 ;void iniTetris(void){	setPal(Gtris_Pal) ;	if(tetriswasinit)	return ;		ulong   dta_size;	img=0 ;	urarlib_get(&img, &dta_size, (char*)"gfxGtris.raw", programData,0) ;	urarlib_get(&sugarMelody, &dta_size, (char*)"Nk-SugarMelody.mod", includeData,0) ; // load a great song from nork :D	bg = img + 64*16 ;	for(cpt=0;cpt<4;cpt++) carre[cpt].set(img+cpt*(16*16),16,16,img) ;	memset(array,0,8*16*4) ;	memset(screen[nflip]+(240*308),3,240*12) ;	memset(screen[!nflip]+(240*308),3,240*12) ;	intro() ;	lastDown=lastMove=GpTickCountGet() ;	setMinMax(pnb,rotate) ;	srand(GpTickCountGet()) ;	posx=2 ; posy=14 ;	pnb = rand()%7 ;	rotate = rand()%4 ;	setMinMax(pnb,rotate);	smile[0] = smile0 ; smile[1] = smile1 ; smile[2] = smile2 ;	tetriswasinit=1 ;}void GtrisMain(void){	clrScr();	intetris=1 ;	killKeyFront() ;	int canDown=0 ;	int downValue ;	iniTetris() ;	static uint *pl=0 ;	if(pl) setPal(pl) ;	while(GpSMCDetected())	{	updateLineBoom();		drawArray();		trk->bgLoad() ;				if(keyUp(kSelect))	{	if(pl) free(pl);							pl = savePal() ;							setPal(gpal) ;							trk->draw() ;							while(keyPush(kSelect)) refreshKey() ;							memset(screen[nflip]+(240*308),3,240*12) ;							memset(screen[!nflip]+(240*308),3,240*12);							setAndFreePal(pl) ;						}		if(keyPush(kR))			if(trk->modSize != 10570)			{	ulong   dta_size;				if(sugarMelody) trk->load(sugarMelody,10570) ;				else	{	urarlib_get(&sugarMelody, &dta_size, (char*)"Nk-SugarMelody.mod", includeData,0) ;						if(sugarMelody) trk->load(sugarMelody,10570) ;					}			 }		downTime = downSpeed ;				if(die()){ while(!clearBuffer()){ drawArray() ; flipScreen() ; } ;  isdie=0 ; lastScore=score ; score=0 ; lastLine = lineNumber ; lineNumber=0 ; }		if(!keyPush(kStart)||!keyPush(kLeft)) canDown=0 ;		if(keyPush(kLeft))		{	if(!keyPush(kUp))				if(!keyPush(kDown))				{	if(keyUp(kStart)) canDown = 1 ;					downValue = (downTime>>2) ;										if(canDown)					 if(keyPush(kStart))							downValue= 42 ;					if(lastDown + downValue<GpTickCountGet()) lastDown-=downTime ;				}		} else { canDown=0; if(keyUp(kStart)) switchRotate() ; }	if(!isdie)//0494931421	{	if(lastDown + downTime < GpTickCountGet())		{			if((posy-- == -posDown)||testPieceArray(pnb,posx,posy,rotate))			{				putPiece(pnb,posx,posy+1,rotate);				searchAndDestructLine(posx+posLeft,posx+3-posRight) ;				posx=2 ; posy=14 ;				pnb = rand()%8 ;								if(pnb==7)				{	if(!(rand()%3)) pnb = 7 ;					else pnb = rand()%7 ;				}								rotate = rand()%4 ;				setMinMax(pnb,rotate);				canDown = 0 ;				killKeyFront();			}			lastDown = GpTickCountGet();		} else	{		updateKey() ;					if(canLeft(pnb,posx,posy,rotate))					{	if(keyUp(kUp)){ if(posx > -posLeft ) posx-- ; lastMove = GpTickCountGet();}						else {	if(keyPush(kUp)){	if(lastMove+420<GpTickCountGet()){														if(posx > -posLeft ) posx-- ;														lastMove = GpTickCountGet();														lastDown += 42<<2 ;													}												}						}					}					if(canRight(pnb,posx,posy,rotate))					{	if(keyUp(kDown))						{	if(posx < 4+posRight) posx++ ;							lastMove = GpTickCountGet();						}else{	if(keyPush(kDown))								{	if(lastMove+420<GpTickCountGet())									{	if(posx < 4+posRight) posx++ ;										lastMove = GpTickCountGet();										lastDown += 42<<2 ;									}								}							 }					}		}	  }		drawPiece(pnb,posx,posy,rotate) ;		flipScreen() ;	} ;	killKeyFront() ;	if(pl) free(pl);	pl = savePal() ;	intetris=0 ;}